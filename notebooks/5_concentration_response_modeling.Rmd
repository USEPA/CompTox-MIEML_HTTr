---
title: "Perform Concentration Response Analysis of MIE Predictions"
date: "3/13/2025"
output: 
  html_notebook:
    code_folding: none
    toc: true
    toc_depth: 1
    toc_float: false
    number_sections: false
---

This notebook uses the tcplfit2 package to perform a concentration response analysis of MIE predictions generated by MIEML trained high performance classifiers

## Data Import

Import model predictions generated in [notebook 4](./4_generate_mieml_predictions.Rmd)
```{r}
MIE_predictions <- readRDS(file = "../data/MIEML_predictions.rds")
```

<br>

Import model performace summaries generated in [notebook 3](./3_summarize_model_performance.Rmd)
```{r}
model_performance <- read.csv(file = "../data/classifier_performance_summary.csv", header = TRUE)
```

<br>

## Evaluate Distribution of DMSO predictions
```{r}
library(ggplot2)
library(plyr)
library(data.table)

#load mieml_httrpl functions
source("../scripts/ML_functions_HTTr.R")

#initialize list to accept plot objects
plot_list <- list() 

#subset down MIE predictions to just those from DMSO (vehicle control) wells
DMSO_predictions <- MIE_predictions[MIE_predictions$chem_id == "DMSO" & !is.na(MIE_predictions$chem_id),]

for (i in unique(DMSO_predictions$target_name)){
  # i = unique(low_dose_predictions$target_name)[2]
  temp_data = data.table(DMSO_predictions[DMSO_predictions$target_name == i,])

  averaged_preds <-temp_data[,. (pred = mean(pred)), by = .(target_name, dose_level, sample_id)]
  averaged_preds$model_name <- "averaged"
  
  temp_data <- rbind.fill(temp_data, averaged_preds)

    
plot_list[[paste0("DMSO_pred_plot_", i)]]  <-  ggplot(data = temp_data, aes(x=as.factor(model_name), y=pred)) + 
      ggtitle(label = paste0("DMSO predictions for ",make_annotations_pretty(i), " models")) +
      geom_boxplot() +
      xlab("Training Algorithm") +
  ylab("Prediction") +
      theme(legend.position="none") 
    
  print(plot_list[[paste0("DMSO_pred_plot_", i)]])
}
```

<br>

print all of the DMSO predictions together in a combined plot
```{r, fig.width=8, fig.height=6}
library(cowplot)
title <- ggdraw() + draw_label("DMSO Predictions", fontface='bold')

plots <- plot_grid(

  plot_list[[1]],
  plot_list[[2]],
  plot_list[[3]],
          ncol = 1,
          nrow = 3
)
  
print(
  plot_grid(title, plots, ncol=1, rel_heights=c(0.1, 1))
  )

```
<br>

Save DMSO prediction plot
```{r}
tiff(filename = "../figures/DMSO_predictions.tiff", height = 6, width = 8, units = "in", res = 300)
print(
  plot_grid(title, plots, ncol=1, rel_heights=c(0.1, 1))
  )
dev.off()
```
<br>

## Concentration Response Analysis of Exemplar Chemicals
```{r}
library(tcplfit2)

#initialize dataframe to catch tcplfit2 results
exemplar_fits <- data.frame()

#step through each target
for (temp_target in unique(MIE_predictions$target_name)){
  #step through each model
  for (temp_model in unique(MIE_predictions[MIE_predictions$target_name == temp_target,]$model_name)){
  message("Analyzing data for MIE: ", temp_target, " with algorithm: ",temp_model)
    
  #subset predictions down to only those associated with this classifier
  by_model <- MIE_predictions[MIE_predictions$target_name == temp_target & MIE_predictions$model_name == temp_model,]
  
  #split off DMSO predictions
  baseline_data <- by_model[by_model$chem_id == "DMSO" & by_model$stype == "vehicle control" & !is.na(by_model$chem_id),]
  
  #calculate baseline metrics from baseline data for this model
  onesd <- sd(baseline_data$pred)
  cutoff = 2*mad(baseline_data$pred)
  bmed <- median(baseline_data$pred)
  
  #for now, only do conc resp analysis for exemplar chemicals - subset data down to just those for the exemplar chemical
  by_model <- by_model[by_model$exemplar_chemical_for_MIE == 1,]
  
  #extract relevant information from this dataframe and format as a list for concentration response analysis with tcplfit2
  conc <- list(by_model$conc)
  resp <- list(by_model$pred)
  row = list(conc = conc, resp = resp, bmed = bmed, cutoff = cutoff, onesd = onesd,name=unique(by_model$chem_name)[1])
  
  #run tcplfit2 based concentration response analysis
  res <- concRespCore(row,fitmodels = c("cnst", "hill", "poly1", "poly2", "pow", "exp2", "exp3", "exp4", "exp5"),conthits = TRUE, do.plot=F)
  
  #add useful information to output
  res$target_name <- temp_target
  res$model_name <- temp_model
 exemplar_fits <-  rbind(res, exemplar_fits)
  }
}
```
<br>

Add an "assay" field by combining the target name and model name fields 
+ tcplfit2 plotting functions use the assay field to generate plot titles
```{r}
exemplar_fits$assay <- paste0(make_annotations_pretty(exemplar_fits$target_name), " ", exemplar_fits$model_name)
```
<br>

Plot results from concentration response analysis of exemplar chemicals
```{r, fig.width=11, fig.height=15}
oldpar <- par(no.readonly = TRUE)
on.exit(par(oldpar))            
par(mfrow=c(5,3),mar=c(4,4,2,2))

for (i in 1:nrow(exemplar_fits)){
concRespPlot(exemplar_fits[i,],ymin=-1.5,ymax=1.5)
}
```
<br>

Save this figure to disk
```{r}
tiff(filename = "../figures/exemplar_chemical_fits.tiff", height = 15, width = 11, units = "in", res = 300)

oldpar <- par(no.readonly = TRUE)
on.exit(par(oldpar))            
par(mfrow=c(5,3),mar=c(4,4,2,2))

print(
for (i in 1:nrow(exemplar_fits)){
concRespPlot(exemplar_fits[i,],ymin=-1.5,ymax=1.5)
}
  )
dev.off()
```
<br>

Merge exemplar chemical hitcall information with classifier performance summary
```{r}
#subset columns
model_performance_revised <- model_performance[c("target_name","model_name","internal_accuracy","holdout_accuracy","chemical_targets","target_members", "holdout_members","n_nulls", "int_acc_emp_pval", "hold_acc_emp_pval", "passed_EST")]

#create temp "assay" column in model_performance_revised to merge exemplar data
model_performance_revised$assay <- paste0(make_annotations_pretty(model_performance_revised$target_name), " ", model_performance_revised$model_name)

model_performance_revised <- merge(model_performance_revised, exemplar_fits[c("assay","name", "hitcall")], by = "assay", all.x = TRUE)

#make annotations pretty
model_performance_revised$target_name <- make_annotations_pretty(model_performance_revised$target_name)

#multiply the "target members" column by two so it's actually the number of training data profiles - change the column name later
model_performance_revised$target_members <- model_performance_revised$target_members * 2

#for this number to be indicative of the number of profiles used in training, need to subtract the profiles in the "holdout_members" column
model_performance_revised$target_members <- model_performance_revised$target_members - model_performance_revised$holdout_members


names(model_performance_revised)
```

Pretty up column names for export
```{r}
model_performance_revised$assay <- NULL
names(model_performance_revised) <- c("MIE", "Training Algorithm", "Internal Accuracy", "Holdout Accuracy", "#Training Chemicals", "#Training Profiles", "#Holdout Profiles", "#Null Models Trained", "Internal Accuracy EST P-val", "Holdout Accuracy EST P-val", "Passed EST", "Exemplar Chemical", "Exemplar Hitcall")
```

save model_performance_revised to disk
```{r}
write.csv(x = model_performance_revised, file = "../data/classifier_performance_summary_with_exemplar_hitcalls.csv")
```

filter high performance classifiers by determining if their corresponding exemplar chemical had a positive hitcall
```{r}
high_performance_classifiers <- model_performance[model_performance$passed_EST == "yes",]

confirmed_high_performance_classifiers <- data.frame()
for (i in 1:nrow(high_performance_classifiers)){
  model_name <- high_performance_classifiers[i,]$model_name
  target_name <- high_performance_classifiers[i,]$target_name
  
  relevant_exemplar_fit <- exemplar_fits[exemplar_fits$target_name == target_name & exemplar_fits$model_name == model_name,]
  
  if (relevant_exemplar_fit$hitcall >= 0.9){
    confirmed_high_performance_classifiers <- rbind(high_performance_classifiers[i,], confirmed_high_performance_classifiers)
  }
}
```

view confirmed high performance classifiers
```{r}
confirmed_high_performance_classifiers
```

what's the median internal and holdout accuracy of these CHPCs
```{r}
median(confirmed_high_performance_classifiers$internal_accuracy)
median(confirmed_high_performance_classifiers$holdout_accuracy)
```


subset MIE_predictions down to only those generated from high performance classifiers
```{r}
#generate a filter column that is just the concatenated target and algorithm name to allow for filtering
MIE_predictions$filter <- paste0(MIE_predictions$target_name, MIE_predictions$model_name)
confirmed_high_performance_classifiers$filter <- paste0(confirmed_high_performance_classifiers$target_name,confirmed_high_performance_classifiers$model_name)

confirmed_MIE_predictions <- MIE_predictions[MIE_predictions$filter %in% confirmed_high_performance_classifiers$filter,]
```

<br> 

## Run Concentration Response Analysis on Confirmed High Performance Classifiers

This step will perform concentration response analysis independently for each unique set of:
+ Confirmed High performance Classifiers
+ Chemical IDs

This may involve calling concRespCore several thousand times.  To speed this up, recommend parallelizing the concentration response step.  To that end, declare the number of cores to be used in parallelization:
```{r}
CORES = 20
```

Perform parallelized concentration response analysis
```{r}
library(doParallel)
library(foreach)

#initialize dataframe to catch tcplfit2 results
all_fits <- data.frame()

for (i in 1:nrow(confirmed_high_performance_classifiers)){
  #i = 1
  message("Analyzing data for MIE: ", confirmed_high_performance_classifiers[i,]$target_name, " with ", confirmed_high_performance_classifiers[i,]$model_name, " model")
  
  #subset data to only the predictions generated by this classifier
  by_model <- confirmed_MIE_predictions[confirmed_MIE_predictions$target_name == confirmed_high_performance_classifiers[i,]$target_name & confirmed_MIE_predictions$model_name == confirmed_high_performance_classifiers[i,]$model_name,]
  
  #parse out predictions from DMSO control wells
  baseline_data <- by_model[by_model$chem_id == "DMSO" & by_model$stype == "vehicle control" & !is.na(by_model$chem_id),]
  
  #calculate baseline metrics from baseline data for this classifier
  onesd <- sd(baseline_data$pred)
  cutoff = 2*mad(baseline_data$pred)
  bmed <- median(baseline_data$pred)
  
  #register cores to enable multithreaded analysis
  registerDoParallel(cores=CORES)
  
  #use foreach to paralleleize concentration response analysis of MIE predictions for each chemical
  fit_catcher <- foreach(k=1:length(unique(na.omit(by_model$chem_id))), .combine = 'rbind', .init = data.frame()) %dopar% {

  chem_id = unique(na.omit(by_model$chem_id))[k]

  by_chemical <- by_model[by_model$chem_id == chem_id & !is.na(by_model$chem_id),]
    
  conc <- list(by_chemical$conc)
  resp <- list(by_chemical$pred)
  row = list(conc = conc, resp = resp, bmed = bmed, cutoff = cutoff, onesd = onesd,name=unique(by_chemical$chem_name)[1])
  
  res <- concRespCore(row,fitmodels = c("cnst", "hill", "poly1", "poly2", "pow", "exp2", "exp3", "exp4", "exp5"),conthits = TRUE, do.plot=F)
  res$target_name <- confirmed_high_performance_classifiers[i,]$target_name
  res$model_name <- confirmed_high_performance_classifiers[i,]$model_name
  res$chem_id <- chem_id
  res$is_MIE_active_training_chem <- by_chemical$is_MIE_active_training_chem[1]
  res$is_MIE_inactive_training_chem <- by_chemical$is_MIE_inactive_training_chem[1]
  res$exemplar_chemical_for_MIE <- by_chemical$exemplar_chemical_for_MIE[1]
  res$MIE_linkage_support_level <- by_chemical$MIE_linkage_support_level[1]
  res
  }
 all_fits <-  rbind(fit_catcher, all_fits)
}
```

<br>

## Export Concentration Response Analysis Results to Disk

<br>

Import sample metadata to add chemical metadata to tcplfit2 output
```{r}
httr_metadata <- readRDS("../data/mongodb_dump/httr_metadata.rds")

chem_info <- unique(httr_metadata[c("chem_id", "dtxsid")])

all_fits <- merge(all_fits, chem_info, by = "chem_id")
```

<br>

Save to disk
```{r}
saveRDS(all_fits, file = "../data/CHPC_conc_resp_analysis_results.rds")
```

<br>

Print session info
```{r}
sessionInfo()
```


