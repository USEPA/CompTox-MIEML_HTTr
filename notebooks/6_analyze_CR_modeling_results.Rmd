---
title: "Analyze Concentration Response Analysis of MIEML Derived MIE Predictions"
author: "Joseph Bundy"
date: "3/13/2025"
output: 
  html_notebook:
    code_folding: none
    toc: true
    toc_depth: 1
    toc_float: false
    number_sections: false
---

<br>

## Data Import

Import concentration response analysis results generated by [notebook 5](../notebooks/5_concentration_response_modeling.Rmd)
```{r}
MIEML_tcplfit2_fits <- readRDS("../data/CHPC_conc_resp_analysis_results.rds")
```

<br>

## Data Cleaning

```{r}
#load mieml_httrpl functions
source("../scripts/ML_functions_HTTr.R")

#generate log10 transformed bmd
MIEML_tcplfit2_fits$log10_bmd <- log10(MIEML_tcplfit2_fits$bmd)

#generate column with pretty MIE names
MIEML_tcplfit2_fits$pretty_MIE_name <- make_annotations_pretty(MIEML_tcplfit2_fits$target_name)

# add method column - handly for merging with invitrodb later later
MIEML_tcplfit2_fits$method <- "HTTr_MIEML"

#remove water samples
MIEML_tcplfit2_fits <- MIEML_tcplfit2_fits[!grepl("Water", MIEML_tcplfit2_fits$name),]

#generate a field that combines target and model names
MIEML_tcplfit2_fits$combined_name <- paste0(MIEML_tcplfit2_fits$pretty_MIE_name, " ", MIEML_tcplfit2_fits$model_name)
```

<br>

## Data Interpretation and Visualization

How many chemicals are present in these data?
```{r}
length(unique(MIEML_tcplfit2_fits$dtxsid))
```

<br>

Filter concentration response analysis results to only the active results
```{r}
library(data.table)
library(stringr)

#load mieml_httrpl functions
source("../scripts/ML_functions_HTTr.R")

# drop results that fail hitcall or ToC thresholds
MIEML_tcplfit2_hits <- MIEML_tcplfit2_fits[MIEML_tcplfit2_fits$hitcall >= 0.9 & MIEML_tcplfit2_fits$top_over_cutoff >= 1,]

#coerce to data.table
MIEML_tcplfit2_hits <- data.table(MIEML_tcplfit2_hits)

#drop entries with NA in hitcall or bmd
MIEML_tcplfit2_hits <- MIEML_tcplfit2_hits[!is.na(MIEML_tcplfit2_hits$hitcall),]
MIEML_tcplfit2_hits <- MIEML_tcplfit2_hits[!is.na(MIEML_tcplfit2_hits$bmd),]

#define simple functions for extracting the highest and lowest tested concentrations from typical tcplfit2 outputs
fun_high <- function(x) {
  max(as.numeric(unlist(str_split(string = x, pattern = "[|]"))))
}

#parse the highest tested concentration used in curve fitting from the conc field
MIEML_tcplfit2_hits$highest_conc <- unlist(lapply(MIEML_tcplfit2_hits$conc, fun_high))

#retain genes only if their BMD was not higher than the highest tested conc
MIEML_tcplfit2_hits <- MIEML_tcplfit2_hits[bmd <= highest_conc,]

#coerce back to dataframe
MIEML_tcplfit2_hits <- data.frame(MIEML_tcplfit2_hits)
```

How many chemicals are active in at least one classifier?
```{r}
length(unique(MIEML_tcplfit2_hits$dtxsid))
```


<br>

How many chemicals achieved a positive hitcall for multiple models?

```{r}
temp <- data.table(MIEML_tcplfit2_hits)
temp <-  temp[,.(unique_models=length(unique(combined_name))),by=dtxsid]
nrow(temp[temp$unique_models > 1,])
```

<br>

Generate Visualizations of Concentration Response Analysis Results

Create sankey flow objects for plotting

+ first, create a simple sankey object and diagram that illustrates the proportion of chemicals found to be active via any MIEML model

```{r}
#create the first level of data with an entry for each unique DTXSID
sankey_data_global <- expand.grid("dtxsid" = unique(MIEML_tcplfit2_fits$dtxsid),
                           "x" = "MIEML Prediction",
                          "node" = "MCF-7 Screen",
                          "next_x" = "Hitcall Filtering",
                          "next_node" = "Not Active")

#create a second level of data by copying this original and modifying the entries for active chems
sankey_data_global$dtxsid <- as.character(sankey_data_global$dtxsid)
sankey_data_global$node <- as.character(sankey_data_global$node)
sankey_data_global$next_node <- as.character(sankey_data_global$next_node)

#create a new layer by copying the old one
temp_sankey_data_global <- sankey_data_global

#update entries in new layer to hitcall filtering and default the node that entries go to as "Not Active"
temp_sankey_data_global$x <- "Hitcall Filtering"
temp_sankey_data_global$node <- "Not Active"

#overwrite node entry for dtxsids present in current hitcalls
temp_sankey_data_global[temp_sankey_data_global$dtxsid %in% MIEML_tcplfit2_hits$dtxsid,]$node <- "Active"

#go back to the original data and overwrite the next_node entries for these chemicals
sankey_data_global[sankey_data_global$dtxsid %in% temp_sankey_data_global[temp_sankey_data_global$node == "Active",]$dtxsid,]$next_node <- "Active"

temp_sankey_data_global$next_x <- NA
temp_sankey_data_global$next_node <- NA

sankey_data_global <- rbind(sankey_data_global, temp_sankey_data_global)

sankey_data_global$members <- 0

for (x in unique(sankey_data_global$x)){
  for (node in unique(sankey_data_global$node)){
    if(nrow(sankey_data_global[sankey_data_global$x == x & sankey_data_global$node == node,]) > 0){
    sankey_data_global[sankey_data_global$x == x & sankey_data_global$node == node,]$members <- nrow(sankey_data_global[sankey_data_global$x == x & sankey_data_global$node == node,])
    }
  }
}

sankey_data_global$label <- paste0(sankey_data_global$node, "\n(", sankey_data_global$members, ")")
```

<br>

Generate the sankey plot
```{r, fig.width=7, fig.height=4}
library(ggsankey)
library(dplyr)
library(ggplot2)

figure_catcher <- list()

sankey_data_global$x <- factor(sankey_data_global$x, levels = unique(unique(sankey_data_global$x), unique(sankey_data_global$next_x)))

sankey_data_global$next_x <- factor(sankey_data_global$next_x, levels = unique(unique(sankey_data_global$x), unique(sankey_data_global$next_x)))

manual_node_levels <- c("MCF-7 Screen",
                        "Not Active",
                        "Active")

fills = c("MCF-7 Screen" = "skyblue",
                        "Not Active" = "grey",
                        "Active"   = "red")


sankey_data_global$node <- factor(sankey_data_global$node, levels = manual_node_levels)
sankey_data_global$next_node <- factor(sankey_data_global$next_node, levels = manual_node_levels)


figure_catcher[["first_level_sankey"]] <- ggplot(sankey_data_global, aes(x = x, next_x = next_x, node = node, next_node = next_node, fill = node, label = label)) +
  geom_sankey(flow.alpha = .8,
              width = 0.1,
              space = 100) +
  geom_sankey_text(size = 3, color = "black", position = position_nudge(x = 0.2), space = 100) +
  scale_fill_manual(values = fills) +
  theme_sankey(base_size = 12) +
  labs(x = NULL) +
  theme(legend.position = "none",
        plot.title = element_text(hjust = .5))

print(figure_catcher[["first_level_sankey"]])
```

<br>

Create a sankey figure to describe progressive filtering of MIEML predictions through this notebook 

+ initialize the data object to be plotted as sankey_data_0 
+ this level will show whether chemicals are predicted active by MIEML just based on concentration response analysis of predictions
```{r}

#initiate data object with 1000 dummy chemicals that will be filtered out in level 1
sankey_data_0 <- expand.grid("chem_id" = c(1:1000),
                           "x" = "MIEML Prediction",
                          "node" = "MCF-7 Screen",
                          "next_x" = "Activity Filtering",
                          "next_node" = "Predicted Negative")

#iterate through each combined name and add values if those samples are retained in the hits object

for (temp_name in unique(MIEML_tcplfit2_hits$combined_name)){
  #temp_name = unique(MIEML_tcplfit2_hits$combined_name)[1]
sankey_data_0 <- rbind(sankey_data_0,
                     expand.grid("chem_id" = unique(MIEML_tcplfit2_hits[MIEML_tcplfit2_hits$combined_name == temp_name,]$chem_id),
                           "x" = "MIEML Prediction",
                          "node" = "MCF-7 Screen",
                          "next_x" = "Activity Filtering",
                          "next_node" = temp_name))
}
```

<br>

Create level 1 data using level 0 data as template

+ This level will filter predictions based on their BMD relative to mechanism agonistic tPODs 

```{r}
sankey_data_1 <- sankey_data_0

#update x and node values using next_node values
sankey_data_1$x <- sankey_data_1$next_x 
sankey_data_1$node <- sankey_data_1$next_node

#update next_x value as Potency filtering
sankey_data_1$next_x <- "Potency Filtering"

#for dummy chem ids, set those next node and x entries to na
sankey_data_1[sankey_data_1$chem_id %in% c(1:1000),]$next_x <- NA
sankey_data_1[sankey_data_1$chem_id %in% c(1:1000),]$next_node <- NA
```

<br>

table MIEML hits by MIE
```{r}
temp <- data.table(MIEML_tcplfit2_hits)
temp <-  temp[,.(count=length(unique(dtxsid))), by=.(pretty_MIE_name,model_name)]
temp
```

<br>

Filter MIEML predictions using mechanism agonistic potency estimates from gene level concentration response analysis

+ First, read in tPOD estimates from gene level curve fitting

```{r}
HTTR_CR_summary <- read.csv("../data/tpod_estimates/tpod_estimates.csv", header = TRUE)
```

<br>

Create figure outlining the MIEML POD relative to Gene CR derived POD
```{r}
#merge MIEML PODs and Gene CR PODs
MIEML_tcplfit2_hits <- merge(MIEML_tcplfit2_hits, HTTR_CR_summary[c("chem_id", "gene_bpac05")], all.x = TRUE)

#log10 transform these values and write to new column
MIEML_tcplfit2_hits$log10_BPAC05 <- log10(MIEML_tcplfit2_hits$gene_bpac05)

#calculate a potency ratio as the difference in potency between the log10 MIEML potency and log10 Gene CR potency
MIEML_tcplfit2_hits$potency_ratio <- MIEML_tcplfit2_hits$log10_bmd - MIEML_tcplfit2_hits$log10_BPAC05
```

<br>

Visulaize differences in potency estimates between MIEML and Gene derived tPOD
```{r}
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

fills = c("AHR Agonism" = gg_color_hue(3)[1],
          "ESR1 Agonism" = gg_color_hue(3)[2],
          "NR3C1 Agonism" = gg_color_hue(3)[3],
          "Other" = "black")

plot_data <- MIEML_tcplfit2_hits

plot_data$combined_name <- factor(plot_data$combined_name, levels = rev(unique(plot_data$combined_name)))

figure_catcher[["potency_ratio_dotplot"]] <- ggplot(data = plot_data, aes(x= combined_name, y=potency_ratio)) + 
  geom_boxplot(aes(x= combined_name, y=potency_ratio, color = pretty_MIE_name), outlier.shape = NA) +
  geom_jitter(aes(color = pretty_MIE_name), width = 0.2) +
  xlab("MIE Name") +
  ylab("Potency Ratio") +
  geom_hline(yintercept = 1, color = "black", linetype='dashed') +
  ylim(c(-6,6)) +
  guides(fill=guide_legend(title="MIEML Prediction")) +
  theme_minimal() +
#  scale_fill_manual(values=fills) +
  #theme(axis.text.x = element_text(size = 10, angle = 60, vjust = 1, hjust=1),
theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust=1),
        axis.text.y = element_text(size = 9),
        strip.text.x = element_text(size = 9),
        legend.position = "none")
#  coord_flip()

figure_catcher[["potency_ratio_dotplot"]]
```

<br>

Regress MIEML potency against Gene CR potency for each classifier
```{r, fig.width= 5, fig.height=9}
plot_data$potency_filter <- plot_data$pretty_MIE_name
plot_data[plot_data$potency_ratio >= 1.0,]$potency_filter <- "Non-Potent"
plot_data$potency_filter <- factor(plot_data$potency_filter, levels = c("AHR Agonism",
                                                                        "ESR1 Agonism",
                                                                        "NR3C1 Agonism",
                                                                        "Non-Potent"))

fills = c("MIEML Active" = "black",
                        "AHR Agonism" = gg_color_hue(3)[1],
                        "ESR1 Agonism" = gg_color_hue(3)[2],
                        "NR3C1 Agonism" = gg_color_hue(3)[3],
                        "Non-Potent" = "brown")

figure_catcher[["potency_ratio_scatter"]] <- ggplot(data = plot_data, aes(x= log10_BPAC05, y=log10_bmd)) + 
  geom_point(aes(x= log10_BPAC05, y=log10_bmd, color = potency_filter), alpha = 0.5, shape = 16) +
  xlab("Log10 tPOD (uM)") +
  ylab("Log10 MIEML BMD (uM)") +
  geom_abline(slope = 1, intercept = 1, color = "brown", linetype='dashed') +
    geom_abline(slope = 1, intercept = 0, color = "black") +
  ylim(c(-3.5,3.5)) +
  xlim(c(-3.5,3.5)) +
  guides(color=guide_legend(title="Potency Filter")) +
  scale_color_manual(values=fills) +
  theme_minimal() +
theme(axis.text.x = element_text(size = 9),
        axis.text.y = element_text(size = 9),
        strip.text.x = element_text(size = 9),
        legend.position = "left",
      legend.direction = "vertical") +
  facet_grid(rows = vars(model_name), cols = vars(pretty_MIE_name))

figure_catcher[["potency_ratio_scatter"]]
```

<br>

What proportion of hits from each model were dropped due to this filter?
```{r}
library(data.table)
potency_filter_summary <- data.table(plot_data)
potency_filter_summary <-  potency_filter_summary[,.(total_chems=length(unique(chem_id))),by=.(combined_name, potency_filter)]

temp <- data.frame()
for (temp_model in unique(potency_filter_summary$combined_name)){
  temp <- rbind(data.frame("combined_name" = temp_model,
                           "n_filtered" = sum(potency_filter_summary[potency_filter_summary$combined_name == temp_model & potency_filter_summary$potency_filter == "Non-Potent",]$total_chems),
                           "total_chems" = sum(potency_filter_summary[potency_filter_summary$combined_name == temp_model,]$total_chems)),
                temp)
}

temp$proportion_filtered <- temp$n_filtered / temp$total_chems
temp
```

<br>

```{r}
summary(temp$proportion_filtered)
```

<br>

```{r}
sd(temp$proportion_filtered)
```

<br>

Retain only the MIEML results where the potency ratio was under 1 - indicating that the target-agnostic tPOD derived from gene level curve fits was no more than 1 order of magnitude lower than the target-specific MIEML derived potency estimate
```{r}
MIEML_tcplfit2_hits <- MIEML_tcplfit2_hits[MIEML_tcplfit2_hits$potency_ratio <= 1.0,]
length(unique(MIEML_tcplfit2_hits$dtxsid))
```

<br>

Generate plot that shows the number of algorithms per MIE that predict a chemical as positive
```{r}
#reminder - this is used later for consensus filtering
n_active_consensus_list <- list("AHR Agonism" = 4,
                       "ESR1 Agonism" = 4,
                       "NR3C1 Agonism" = 4)

consensus_table <- data.table(MIEML_tcplfit2_hits)
consensus_table <-  consensus_table[,.(count=length(unique(model_name))), by=.(pretty_MIE_name,dtxsid)]

consensus_table$consensus_filter <- consensus_table$pretty_MIE_name

for (i in unique(consensus_table$pretty_MIE_name)){
  critical_value <- n_active_consensus_list[[i]]
  consensus_table[consensus_table$pretty_MIE_name == i & consensus_table$count < critical_value,]$consensus_filter <- "Non-consensus"
}

consensus_table$consensus_filter <- factor(x = consensus_table$consensus_filter, levels = c("AHR Agonism", "ESR1 Agonism", "NR3C1 Agonism", "Non-consensus"))

fills = c("MIEML Active" = "black",
                        "AHR Agonism" = gg_color_hue(3)[1],
                        "ESR1 Agonism" = gg_color_hue(3)[2],
                        "NR3C1 Agonism" = gg_color_hue(3)[3],
                        "Non-consensus" = "grey")

figure_catcher[["consensus_histogram"]] <- ggplot(data = consensus_table, aes(x = count, fill = consensus_filter)) + 
  geom_bar() +
  xlab("# Algorithms with Positive Prediction") +
  ylab("# Chemicals") +
  guides(fill=guide_legend(title="Consensus Filter")) +
  scale_fill_manual(values=fills) +
  theme_minimal() +
theme(axis.text.x = element_text(size = 9),
        axis.text.y = element_text(size = 9),
        strip.text.x = element_text(size = 9),
        legend.position = "right") +
 facet_grid(rows = vars(pretty_MIE_name), scales = "free_x")

figure_catcher[["consensus_histogram"]]
```

Generate plot that shows the number of algorithms per MIE that predict a chemical as positive

<br>

create sankey level 2 object
```{r}
#create level 2 object using level 1 as a template
sankey_data_2 <- sankey_data_1

#drop the entries that have NAs in next_x field
sankey_data_2 <- sankey_data_2[!is.na(sankey_data_2$next_x),]

#update x and node entries using next node and next x entries
sankey_data_2$x <- sankey_data_2$next_x
sankey_data_2$node <- sankey_data_2$next_node

#update next x as consensus filtering
sankey_data_2$next_x <- "Consensus Filtering"

#iterate through each combined name in the hit object and cross-reference the remaining entries with those in the sankey data object

#if entries in the sankey data object are not in the hit object, set their next x and next node values to NA, as they've been filtered out

for (combined_name in unique(MIEML_tcplfit2_hits$combined_name)){
  #combined_name = unique(MIEML_tcplfit2_hits$combined_name)[1]
  temp_relevant_hit_data <- MIEML_tcplfit2_hits[MIEML_tcplfit2_hits$combined_name == combined_name,]
  if (nrow(sankey_data_2[sankey_data_2$node == combined_name & sankey_data_2$chem_id %notin% temp_relevant_hit_data$chem_id,]) > 0){
  sankey_data_2[sankey_data_2$node == combined_name & sankey_data_2$chem_id %notin% temp_relevant_hit_data$chem_id,]$next_x <- NA
  sankey_data_2[sankey_data_2$node == combined_name & sankey_data_2$chem_id %notin% temp_relevant_hit_data$chem_id,]$next_node <- NA
  }
}

#now, step back through each combined name in level 1 data and re-define next node entries that were filtered out by tpod to "Non-specific"
sankey_data_1$next_node <- as.character(sankey_data_1$next_node)

for (combined_name in na.omit(unique(sankey_data_1$next_node))){
  #combined_name = na.omit(unique(temp_sankey_data_1$next_node))[1]
  temp_relevant_level_2_data <- sankey_data_2[sankey_data_2$node == combined_name & is.na(sankey_data_2$next_x),]
  
  sankey_data_1[sankey_data_1$next_node == combined_name & sankey_data_1$chem_id %in% temp_relevant_level_2_data$chem_id, "next_node"] <- "Non-Potent"
}

# finally, modify sankey_data_2 node columns to match 

sankey_data_2$node <- as.character(sankey_data_2$node)

sankey_data_2[is.na(sankey_data_2$next_x), "node"] <- "Non-Potent"
```

<br>

Before applying further filtering based on consensus approach, evaluate hitcalls for target-linked reference chemicals (both those used in training and exemplars)


```{r}
temp_data_linked_to_targets <- unique(MIEML_tcplfit2_fits[MIEML_tcplfit2_fits$is_MIE_active_training_chem == 1 | MIEML_tcplfit2_fits$exemplar_chemical_for_MIE == 1,]$chem_id)

temp_data_linked_to_targets <- MIEML_tcplfit2_fits[MIEML_tcplfit2_fits$chem_id %in% temp_data_linked_to_targets,]

#floor and ceiling values to 0 and 1 (respectively) on the critical value of 0.9
temp_data_linked_to_targets[temp_data_linked_to_targets$hitcall < 0.9,]$hitcall <- 0
temp_data_linked_to_targets[temp_data_linked_to_targets$hitcall >= 0.9,]$hitcall <- 1


temp_data_linked_to_targets <- temp_data_linked_to_targets[
  with(temp_data_linked_to_targets, order(pretty_MIE_name, model_name)),
]
```

<br> 

Generate heatmap of exemplar chemical hitcalls across all confirmed high performance classifiers

First, pivot the temp_data_linked_to_targets object into wide format
```{r}
library(tidyr)
library(tibble)

heatmap_object <- data.frame(pivot_wider(data = temp_data_linked_to_targets[c("chem_id",
                                                                           "name",
                                                                           "hitcall", 
                                                                           "dtxsid", 
                                                                           "target_name",
                                                                           "model_name",
                                                                           "is_MIE_active_training_chem",
                                                                           "exemplar_chemical_for_MIE",
                                                                           "pretty_MIE_name")], 
                                         names_from = chem_id,
                                         values_from = hitcall,
                                        id_cols = c("pretty_MIE_name", 
                                                    "model_name"),
                                         values_fill = 0))

heatmap_object$pretty_MIE_name <- factor(heatmap_object$pretty_MIE_name, levels = unique(heatmap_object$pretty_MIE_name))

heatmap_object$model_name <- factor(heatmap_object$model_name, levels = unique(heatmap_object$model_name))

```

<br>

Define function to manually control ggplot2 color annotations

```{r}
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
```

Prepare annotations for heatmap 
```{r}
#generate a matrix object containing only the hitcalls
heatmap_matrix <- heatmap_object[3:ncol(heatmap_object)]

#generate color annotation object by subsetting data down to only those chemicals either used in training or exemplar chemicals
col_annotation_object <- MIEML_tcplfit2_fits[MIEML_tcplfit2_fits$is_MIE_active_training_chem == 1 | MIEML_tcplfit2_fits$exemplar_chemical_for_MIE == 1,]

#take the unique set of entries for this reduced dataframe
col_annotation_object <- unique(col_annotation_object[c("chem_id", "dtxsid", "name","pretty_MIE_name", "is_MIE_active_training_chem", "exemplar_chemical_for_MIE")])

#convert relevant fields to factors
col_annotation_object$pretty_MIE_name <- factor(col_annotation_object$pretty_MIE_name, levels = levels(heatmap_object$pretty_MIE_name))

col_annotation_object$is_MIE_active_training_chem <- factor(col_annotation_object$is_MIE_active_training_chem, levels = c(1,0))

col_annotation_object$exemplar_chemical_for_MIE <- factor(col_annotation_object$exemplar_chemical_for_MIE, levels = c(1,0))
```

<br>

Generate heatmap of exemplar chemical hitcalls across confirmed high performance classifiers

```{r, fig.width=12, fig.height=7}
library(ComplexHeatmap)
library(circlize)

 row_annotation_list <- list(Target =  c(gg_color_hue(length(unique(heatmap_object$pretty_MIE_name)))),
                             Algorithm = c(gg_color_hue(length(unique(heatmap_object$model_name)))))
 
 names(row_annotation_list$Target) <- levels(heatmap_object$pretty_MIE_name)
 names(row_annotation_list$Algorithm) <- levels(heatmap_object$model_name)
 
 
 col_annotation_list <- list(Target =  c(gg_color_hue(length(unique(col_annotation_object$pretty_MIE_name)))),
                             Training_Chem =  c("Red", "White"),
                             Exemplar_Chem =  c("Red", "White"))
 
 names(col_annotation_list$Target) <- levels(col_annotation_object$pretty_MIE_name)
 names(col_annotation_list$Training_Chem) <- levels(col_annotation_object$is_MIE_active_training_chem)
 names(col_annotation_list$Exemplar_Chem) <- levels(col_annotation_object$exemplar_chemical_for_MIE)
 
ht_list <- Heatmap(heatmap_matrix,
                   column_title = "Sample",
                   row_title = "Model",
        col = colorRamp2(breaks = c(0, 1), colors = c("grey", "blue")),
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_heatmap_legend = FALSE,
        row_split = heatmap_object$pretty_MIE_name,
        column_split = col_annotation_object$pretty_MIE_name,
        show_column_names = TRUE,
        row_labels = heatmap_object$pretty_MIE_name,
        column_labels = col_annotation_object$name,
        column_names_rot = -45,
        left_annotation = rowAnnotation(Target = heatmap_object$pretty_MIE_name,
                                           Algorithm = heatmap_object$model_name,
                                          col = row_annotation_list),
        
         top_annotation = HeatmapAnnotation(Target = col_annotation_object$pretty_MIE_name,
                                           Exemplar_Chem = col_annotation_object$exemplar_chemical_for_MIE,
                                          col = col_annotation_list)
)

figure_catcher[["training_chem_heatmap"]] <- draw(ht_list,
     heatmap_legend_side = "right", 
     annotation_legend_side = "top",
     merge_legend = TRUE
     )

print(figure_catcher[["training_chem_heatmap"]])
```

<br>

Filter predictions using a consensus approach:
```{r}
#initialize a dataframe to accept these hits
MIEML_tcplfit2_consensus_hits <- data.frame()

#step through each MIE
for (i in names(n_active_consensus_list)){

#subset data down to only those classifiers trained on this MIE and build a table of how many models returned an active prediction for that chemical
temp <- MIEML_tcplfit2_hits[MIEML_tcplfit2_hits$pretty_MIE_name == i,]
temp <- data.table(temp)
temp <-  temp[,.(n_model_active=length(unique(model_name))), by=dtxsid]

#filter down this list based on the number of models a chemical has to be active in to be considered a consensus prediction
consensus_chems <- temp[temp$n_model_active >= n_active_consensus_list[i],]

#subset down the MIEML_tcplfit2_hits object to only consensus predictions
consensus_chems <- MIEML_tcplfit2_hits[MIEML_tcplfit2_hits$pretty_MIE_name == i & MIEML_tcplfit2_hits$dtxsid %in% consensus_chems$dtxsid,]

#add these results to the dataframe
MIEML_tcplfit2_consensus_hits <- rbind(consensus_chems, MIEML_tcplfit2_consensus_hits)
}

#overwrite MIEML_tcplfit2_hits object and remove the consensus object to avoid confusion
MIEML_tcplfit2_hits <- MIEML_tcplfit2_consensus_hits
rm(MIEML_tcplfit2_consensus_hits)
```

<br>

How many total predictions are remaining after consensus filtering?
```{r}
nrow(MIEML_tcplfit2_hits)
```

<br>

How many unique chemicals does this span?
```{r}
length(unique(MIEML_tcplfit2_hits$dtxsid))
```

<br>

table MIEML hits by MIE
```{r}
temp <- data.table(MIEML_tcplfit2_hits)
temp <-  temp[,.(count=length(unique(dtxsid))), by=.(pretty_MIE_name,model_name)]
temp
```

<br>

How many positive predictions are there on average for NR3C1 Agonist models?
```{r}
mean(temp[temp$pretty_MIE_name == "NR3C1 Agonism",]$count)
```

<br> 

Save these filtered MIE predictions to disk

```{r}
write.csv(MIEML_tcplfit2_hits, file = "../data/filtered_MIE_predictions.csv")
```


<br>

Generate an additional layer for sankey plot now that predictions have been filtered using consensus approach


```{r}
#copy data from level 2 object
sankey_data_3 <- sankey_data_2

#drop entries where next node was set to NA
sankey_data_3 <- sankey_data_3[!is.na(sankey_data_3$next_node),]

#update x and node entries using next node and next x entries
sankey_data_3$x <- sankey_data_3$next_x
sankey_data_3$node <- sankey_data_3$next_node

#update next x as consensus filtering
sankey_data_3$next_x <- "Specificity Filtering"

#iterate through each combined name in the hit object and cross-reference the remaining entries with those in the sankey data object

#if entries in the sankey data object are not in the hit object, set their next x and next node values to NA, as they've been filtered out
for (combined_name in unique(MIEML_tcplfit2_hits$combined_name)){
  #combined_name = unique(MIEML_tcplfit2_hits$combined_name)[1]
  temp_relevant_hit_data <- MIEML_tcplfit2_hits[MIEML_tcplfit2_hits$combined_name == combined_name,]
  if (nrow(sankey_data_3[sankey_data_3$node == combined_name & sankey_data_3$chem_id %notin% temp_relevant_hit_data$chem_id,]) > 0){
  sankey_data_3[sankey_data_3$node == combined_name & sankey_data_3$chem_id %notin% temp_relevant_hit_data$chem_id,]$next_x <- NA
  sankey_data_3[sankey_data_3$node == combined_name & sankey_data_3$chem_id %notin% temp_relevant_hit_data$chem_id,]$next_node <- NA
  }
}

#now, step back through each combined name in level 2 data and re-define next node entries that were filtered out by tpod to "Non-Consensus"
sankey_data_2$next_node <- as.character(sankey_data_2$next_node)

for (combined_name in na.omit(unique(sankey_data_2$next_node))){
  #combined_name = na.omit(unique(sankey_data_2$next_node))[1]
  temp_relevant_level_3_data <- sankey_data_3[sankey_data_3$node == combined_name & is.na(sankey_data_3$next_x),]
  
  sankey_data_2[!is.na(sankey_data_2$next_node) & sankey_data_2$next_node == combined_name & sankey_data_2$chem_id %in% temp_relevant_level_3_data$chem_id, "next_node"] <- "Non-Consensus"
}

# finally, modify sankey_data_2 node columns to match 
sankey_data_3$node <- as.character(sankey_data_3$node)

sankey_data_3[is.na(sankey_data_3$next_x), "node"] <- "Non-Consensus"
```

<br>

create a ggsankey diagram that describes the filtering process

Total set of chemicals on which predictions were generated yields:

   - Innactive chemicals
   
   - Chemicals active for one of 15 classifiers which are then filtered by cross-referencing tPOD yielding
       
       - Chemicals that are tossed from tPOD filtering
       
       - Chemicals active for 15 classifiers which are then filtered by consistency of activity yielding:
       
            - Chemicals that are tossed due to consensus filtering
            
            - Chemicals active for 3 MIEs which are then filtered by cross-referencing MIEML BMDs to remove predictions yielding:
            
                 - Chemicals that are tossed due to specific activity filtering
                 
                 - Chemicals active for 3 MIEs
   

```{r, fig.width=13, fig.height=10}

temp_sankey_data <- rbind(sankey_data_0[sankey_data_0$chem_id %notin% c(1:1000),], 
                          sankey_data_1[!is.na(sankey_data_1$next_x),],
                          sankey_data_2,
                          sankey_data_3)

temp_sankey_data <- data.table(temp_sankey_data)

temp_sankey_data[next_x == "Specificity Filtering", next_node := NA]
temp_sankey_data[next_x == "Specificity Filtering", next_x := NA]

temp_sankey_data <- data.frame(temp_sankey_data)

temp_sankey_data$members <- 0

for (x in unique(temp_sankey_data$x)){
  #x = unique(temp_sankey_data$x)[1]
  for (node in unique(temp_sankey_data$node)){
    #node = unique(temp_sankey_data$node)[1]
    if(nrow(temp_sankey_data[temp_sankey_data$x == x & temp_sankey_data$node == node,]) > 0){
    temp_sankey_data[temp_sankey_data$x == x & temp_sankey_data$node == node,]$members <- nrow((temp_sankey_data[temp_sankey_data$x == x & temp_sankey_data$node == node,]))
    }
  }
}

temp_sankey_data$label <- temp_sankey_data$node

temp_sankey_data$label <- gsub(temp_sankey_data$label, pattern = "AHR Agonism", replace = "")
temp_sankey_data$label <- gsub(temp_sankey_data$label, pattern = "NR3C1 Agonism", replace = "")
temp_sankey_data$label <- gsub(temp_sankey_data$label, pattern = "ESR1 Agonism", replace = "")

temp_sankey_data$label <- paste0(temp_sankey_data$label, " (", temp_sankey_data$members, ")")

temp_sankey_data$x <- as.character(temp_sankey_data$x)
temp_sankey_data$node <- as.character(temp_sankey_data$node)

temp_sankey_data[temp_sankey_data$node == "MCF-7 Screen",]$node <- "MIEML Active"
temp_sankey_data[temp_sankey_data$x == "MIEML Prediction",]$x <- "Hitcall Filtering"

 temp_sankey_data$next_x <- as.character(temp_sankey_data$next_x)
temp_sankey_data[temp_sankey_data$x == "Hitcall Filtering",]$next_x <- " "
temp_sankey_data[temp_sankey_data$x == "Activity Filtering",]$x <- " "

temp_sankey_data$x <- factor(temp_sankey_data$x, levels = unique(unique(temp_sankey_data$x), unique(temp_sankey_data$next_x)))
temp_sankey_data$next_x <- factor(temp_sankey_data$next_x, levels = unique(unique(temp_sankey_data$x), unique(temp_sankey_data$next_x)))


manual_node_levels <- c("MIEML Active",
                        "AHR Agonism svmLinear",
                        "AHR Agonism svmPoly",
                        "AHR Agonism svmRadial",
                        "AHR Agonism rf",
                        "AHR Agonism mlpML",
                        "ESR1 Agonism svmLinear",
                        "ESR1 Agonism rf",  
                        "ESR1 Agonism svmPoly",
                        "ESR1 Agonism svmRadial",
                        "ESR1 Agonism mlpML",  
                        "NR3C1 Agonism svmLinear",
                        "NR3C1 Agonism svmPoly",
                        "NR3C1 Agonism svmRadial",
                        "NR3C1 Agonism rf",
                        "NR3C1 Agonism mlpML",
                        "Non-Potent",
                        "Non-Consensus")


temp_sankey_data$node <- factor(temp_sankey_data$node, levels = manual_node_levels)
temp_sankey_data$next_node <- factor(temp_sankey_data$next_node, levels = manual_node_levels)
temp_sankey_data[!is.na(temp_sankey_data$next_x),]$label <- NA

temp_sankey_data$fill <- temp_sankey_data$node
temp_sankey_data$fill <- gsub(temp_sankey_data$fill, pattern = " svmLinear", replacement = "")
temp_sankey_data$fill <- gsub(temp_sankey_data$fill, pattern = " svmPoly", replacement = "")
temp_sankey_data$fill <- gsub(temp_sankey_data$fill, pattern = " svmRadial", replacement = "")
temp_sankey_data$fill <- gsub(temp_sankey_data$fill, pattern = " mlpML", replacement = "")
temp_sankey_data$fill <- gsub(temp_sankey_data$fill, pattern = " rf", replacement = "")


fills = c("MIEML Active" = "black",
                        "AHR Agonism" = gg_color_hue(3)[1],
                        "ESR1 Agonism" = gg_color_hue(3)[2],
                        "NR3C1 Agonism" = gg_color_hue(3)[3],
                        "Non-Potent" = "brown",
                        "Non-Consensus" = "grey")

figure_catcher[["lower_level_sankey"]] <- ggplot(temp_sankey_data, aes(x = x, next_x = next_x, node = node, next_node = next_node, fill = fill, label = label)) +
  geom_sankey(flow.alpha = .8,
              width = 0.05,
              space = 75) +
  geom_sankey_text(size = 3.3, aes(color = fill), position = position_nudge(x = 0.3), space = 75) +
  #geom_sankey_text(size = 2.5, aes(color = fill), position = position_nudge(x = 0.3), space = 75) +
  
  scale_fill_manual(values = fills) +
  scale_color_manual(values = fills) +
  theme_sankey(base_size = 15) +
  labs(x = NULL) +
  theme(legend.position = "bottom",
        plot.title = element_text(hjust = .5),
        plot.margin = unit(c(0.2, 1.75, 0.2, 0.2), 
                                "inches"))

print(figure_catcher[["lower_level_sankey"]])

```

export just this figure to be used in poster (6/17/2024)
```{r}
tiff(filename = "../figures/sankey_plot_only.tiff", height = 5.2, width = 12, units = "in", res = 300)
print(figure_catcher[["lower_level_sankey"]])
dev.off()
```

<br>

## Compare Predictions from MIEML and InvitroDB

Import toxcast data associated with the MIEs of interest

```{r}
library(readxl)

#import data from ESR toxcast model
ESR1_ToxCast_data <- data.frame(read_excel("../data/invitrodb/ER superMatrix prod_internal_invitrodb_v4_1 2023-12-18.xlsx"))

#filter down to only the chemicals present in this screen
ESR1_ToxCast_data <- ESR1_ToxCast_data[ESR1_ToxCast_data$dtxsid %in% MIEML_tcplfit2_fits$dtxsid,]

#distill this object down into hits using filtering steps Richard outlined in our meeting on 2/8/2024

#step1 - ensure that the agonist confidence score is greater than 0
ESR1_ToxCast_hits <- ESR1_ToxCast_data[ESR1_ToxCast_data$agonist_confidence_score > 0,]

#step2 - ensure that either the auc.agonist or auc.antagonist columns have a value greater than 0.1
ESR1_ToxCast_hits <- ESR1_ToxCast_hits[ESR1_ToxCast_hits$AUC.Agonist >= 0.1 | ESR1_ToxCast_hits$AUC.Antagonist >= 0.1,]

#step3 - ensure that the auc.agonist value is greater than the auc.antagonist value 
ESR1_ToxCast_hits <- ESR1_ToxCast_hits[ESR1_ToxCast_hits$AUC.Agonist > ESR1_ToxCast_hits$AUC.Antagonist,]

#step4 - ensure that the AUC.agonist value is greater than all the individual assay level AUCs
relevant_row_names <- names(ESR1_ToxCast_hits[17:40])

for (i in nrow(ESR1_ToxCast_hits)){
  if (ESR1_ToxCast_hits[i,]$AUC.Agonist < max(ESR1_ToxCast_hits[i,relevant_row_names])){
    ESR1_ToxCast_hits <- ESR1_ToxCast_hits[-c(i),]
  }
}

AHR_and_NR3C1_ToxCast_data <- read.csv(file = "../data/invitrodb/res_httr_mcf7_ph1_toxcast_AHR_NR3C1_selective.csv", header = TRUE)

AHR_and_NR3C1_ToxCast_data <- AHR_and_NR3C1_ToxCast_data[AHR_and_NR3C1_ToxCast_data$dsstox_substance_id %in% MIEML_tcplfit2_fits$dtxsid,]
```

<br>

link the toxcast coverage table to specific MIEML MIE names

```{r}
toxcast_coverage <- ESR1_ToxCast_data[c("dtxsid", "name", "AUC.Agonist")]
names(toxcast_coverage)[3] <- "ESR1_Agonism_model_AUC"
toxcast_coverage$mie_flag <- "ESR1 Agonism"

temp <- AHR_and_NR3C1_ToxCast_data[AHR_and_NR3C1_ToxCast_data$outcome != "insufficient data",]
temp[temp$assay_target == "AHR_Positive",]$assay_target <- "AHR Agonism"
temp[temp$assay_target == "NR3C1_Positive",]$assay_target <- "NR3C1 Agonism"
temp <- temp[c("dsstox_substance_id", "chnm", "assay_target")]
temp$holder <- NA
temp <- temp[c("dsstox_substance_id", "chnm", "holder", "assay_target")]
names(temp) <- names(toxcast_coverage)

toxcast_coverage <- rbind(toxcast_coverage, temp)
```

<br>

summarize these data as toxcast predictions
```{r}
toxcast_hits <- ESR1_ToxCast_hits[c("dtxsid", "name", "AUC.Agonist")]
names(toxcast_hits)[3] <- "ESR1_Agonism_model_AUC"
toxcast_hits$mie_flag <- "ESR1 Agonism"
toxcast_hits$method <- "Toxcast_ER_model"

AHR_and_NR3C1_ToxCast_hits <- AHR_and_NR3C1_ToxCast_data[AHR_and_NR3C1_ToxCast_data$outcome == "active",]

AHR_and_NR3C1_ToxCast_hits <- AHR_and_NR3C1_ToxCast_hits[c("dsstox_substance_id", "chnm", "assay_target")]

AHR_and_NR3C1_ToxCast_hits[AHR_and_NR3C1_ToxCast_hits$assay_target == "AHR_Positive",]$assay_target <- "AHR Agonism"
AHR_and_NR3C1_ToxCast_hits[AHR_and_NR3C1_ToxCast_hits$assay_target == "NR3C1_Positive",]$assay_target <- "NR3C1 Agonism"

AHR_and_NR3C1_ToxCast_hits$ESR1_Agonism_model_AUC <- NA

AHR_and_NR3C1_ToxCast_hits <- AHR_and_NR3C1_ToxCast_hits[c("dsstox_substance_id",
                                                           "chnm",
                                                           "ESR1_Agonism_model_AUC",
                                                           "assay_target")]

names(AHR_and_NR3C1_ToxCast_hits) <- names(toxcast_hits)[1:4]

AHR_and_NR3C1_ToxCast_hits$method <- "Toxcast_NR3C1_Positive_Assays"

AHR_and_NR3C1_ToxCast_hits[AHR_and_NR3C1_ToxCast_hits$mie_flag == "AHR Agonism",]$method <- "Toxcast_AHR_Positive_Assays"

toxcast_hits <- rbind(toxcast_hits, AHR_and_NR3C1_ToxCast_hits)

toxcast_hits$is_MIE_active_training_chem <- 0
toxcast_hits$size <- 3
```

<br>

Import HTTr metadata to be used in next section

```{r}
httr_metadata <- readRDS("/ccte/projects1/HTTr/MIE_prediction/MIEML/temposeq/mieml_httrpl/data/mongodb_dump/httr_metadata.rds")
```

<br>

Step through each MIEML classifier and generate stacked bar graph depicting the overlap of MIEML and InvitroDB derived predictions

```{r, fig.width=10, fig.height=6}
toxcast_mieml_summary_data <- data.frame()

for (MIE_name in unique(MIEML_tcplfit2_hits$pretty_MIE_name)){
  #MIE_name = unique(MIEML_tcplfit2_hits$pretty_MIE_name)[1]
  for (model_name in unique(MIEML_tcplfit2_hits[MIEML_tcplfit2_hits$pretty_MIE_name == MIE_name,]$model_name)){
  #model_name = unique(MIEML_tcplfit2_hits[MIEML_tcplfit2_hits$pretty_MIE_name == MIE_name,]$model_name)[1]
    
    relevant_MIEML_data <- MIEML_tcplfit2_hits[MIEML_tcplfit2_hits$pretty_MIE_name == MIE_name & MIEML_tcplfit2_hits$model_name == model_name,]
    
    relevant_toxcast_data <- toxcast_hits[toxcast_hits$mie_flag == MIE_name & toxcast_hits$dtxsid %in% httr_metadata$dtxsid,]
    
    if(nrow(relevant_toxcast_data) > 0){
      temp_output <- toxcast_coverage[toxcast_coverage$dtxsid %in% httr_metadata$dtxsid & toxcast_coverage$mie_flag == MIE_name,]
      temp_output$MIEML_prediction <- "Inactive"
      temp_output[temp_output$dtxsid %in% relevant_MIEML_data$dtxsid,]$MIEML_prediction <- "Active"
      
      temp_output$toxcast_prediction <- "Toxcast Inactive"
      temp_output[temp_output$dtxsid %in% relevant_toxcast_data$dtxsid,]$toxcast_prediction <- "Toxcast Active"
      temp_output$model_name <- model_name
      
      toxcast_mieml_summary_data <- rbind(temp_output, toxcast_mieml_summary_data)
    }
  }
}

toxcast_mieml_summary_data$plot_value <- paste0(toxcast_mieml_summary_data$mie_flag, " ", toxcast_mieml_summary_data$model_name)

toxcast_mieml_summary_data$fill <- toxcast_mieml_summary_data$mie_flag
toxcast_mieml_summary_data[toxcast_mieml_summary_data$MIEML_prediction == "Inactive",]$fill <- "Inactive"
toxcast_mieml_summary_data$fill <- factor(toxcast_mieml_summary_data$fill, levels = c("AHR Agonism", "ESR1 Agonism", "NR3C1 Agonism", "Inactive"))

fills = c(
  "AHR Agonism" = gg_color_hue(3)[1],
  "ESR1 Agonism" = gg_color_hue(3)[2],
  "NR3C1 Agonism" = gg_color_hue(3)[3],
  "Inactive" = "grey")



figure_catcher[["toxcast_histogram"]] <- ggplot(data = toxcast_mieml_summary_data, aes(fill= fill, x=plot_value)) + 
    geom_bar(position="stack", stat="count") +
  coord_flip() +
  xlab("MIE Name") +
  ylab("# Chemicals") +
  guides(fill=guide_legend(title="MIEML Prediction")) +
  #scale_fill_manual(values=fills) +
  theme_minimal() +
  scale_fill_manual(name='Regression Model',
                     breaks=c('AHR Agonism', 'ESR1 Agonism', 'NR3C1 Agonism', 'Inactive'),
                     values=c('AHR Agonism'= gg_color_hue(3)[1], 'ESR1 Agonism'= gg_color_hue(3)[2], 'NR3C1 Agonism'= gg_color_hue(3)[3], 'Inactive' = 'grey')) +
  theme(axis.text.x = element_text(size = 9),
        axis.text.y = element_text(size = 9),
        axis.title.y = element_blank(),
        strip.text.x = element_text(size = 9),
        legend.position = "bottom",
          legend.box = "vertical") +

  facet_grid(cols = vars(toxcast_prediction), scales = "free")


print(figure_catcher[["toxcast_histogram"]])
```
<br>

Save figure to disk

```{r, fig.height= 5, fig.width=13}
tiff(filename = "../figures/stacked_bargraph.tiff", height = 4, width = 10, units = "in", res = 300)
print(figure_catcher[["toxcast_histogram"]])
dev.off()
```

<br>

How many chemicals were screened in HTTr that also have ToxCast data for at least one target in ToxCast?

```{r}
length(unique(toxcast_mieml_summary_data$dtxsid))
```

<br>

calculate sensitivity and specificty for each classifier using invitroDB as truth
```{r}
library(epitools)
temp_out <- data.frame()
for (target in unique(toxcast_mieml_summary_data$mie_flag)){
  for (model in unique(toxcast_mieml_summary_data[toxcast_mieml_summary_data$mie_flag == target,]$model_name)){
  
  TP <- NULL
  TN <- NULL
  FP <- NULL
  FN <- NULL
  
  TP <- as.numeric(nrow(toxcast_mieml_summary_data[toxcast_mieml_summary_data$mie_flag == target & toxcast_mieml_summary_data$model_name == model & toxcast_mieml_summary_data$MIEML_prediction == "Active" & toxcast_mieml_summary_data$toxcast_prediction == "Toxcast Active",]))
  
  TN <- as.numeric(nrow(toxcast_mieml_summary_data[toxcast_mieml_summary_data$mie_flag == target & toxcast_mieml_summary_data$model_name == model & toxcast_mieml_summary_data$MIEML_prediction == "Inactive" & toxcast_mieml_summary_data$toxcast_prediction == "Toxcast Inactive",]))
  
  FP <- as.numeric(nrow(toxcast_mieml_summary_data[toxcast_mieml_summary_data$mie_flag == target & toxcast_mieml_summary_data$model_name == model & toxcast_mieml_summary_data$MIEML_prediction == "Active" & toxcast_mieml_summary_data$toxcast_prediction == "Toxcast Inactive",]))
  
  FN <- as.numeric(nrow(toxcast_mieml_summary_data[toxcast_mieml_summary_data$mie_flag == target & toxcast_mieml_summary_data$model_name == model & toxcast_mieml_summary_data$MIEML_prediction == "Inactive" & toxcast_mieml_summary_data$toxcast_prediction == "Toxcast Active",]))
  
  Sensitivity = TP / (TP + FN)
  Specificity = TN / (TN + FP)
  MCC = (TP * TN - FP * FN) / sqrt((TP + FP) * (TP + FN) * (TN + FP) * (TN + FN))

  #perform an odds ratio test
  is_active_by_MIEML <- c('True', 'False')
  is_active_by_toxcast <- c('True', 'False')
  
  OR_object <- matrix(c(TP, #num chems active in both MIEML and ToxCast
                        FP, #num chems active in MIEML but inactive in ToxCast
                        FN, #num chems not active in MIEML or ToxCast
                        TN), #num chems inactive in MIEML but active in ToxCast
                      nrow=2, ncol=2,byrow=TRUE)
  
  dimnames(OR_object) <- list('is_active_by_MIEML'=is_active_by_MIEML, 
                              'is_active_by_toxcast'=is_active_by_toxcast)
  OR_result <- oddsratio.fisher(OR_object, rev = "neither")
  
  temp_out <- rbind(data.frame("MIE" = target,
                               "model" = model,
                               "TP" = TP,
                               "TN" = TN,
                               "FP" = FP,
                               "FN" = FN,
                               "Sensitivity" = Sensitivity,
                               "Specificity" = Specificity,
                               "MCC" = MCC,
                               "OR_pvalue" = OR_result$p.value[4],
                               "OR_magnitude" = OR_result$measure[2],
                               "OR_lbound" = OR_result$measure[4],
                               "OR_ubound" = OR_result$measure[6]), temp_out)

}  
}

temp_out

#save file to disk
write.csv(temp_out, "../data/MIEML_invitrodb_performance_metrics.csv")
```
<br>

What is the mean OR for AHR Agonism models?
```{r}
mean(temp_out[temp_out$MIE == "AHR Agonism",]$OR_magnitude)
```

<br>

create plot of the MCC results
```{r}
temp_out$x <- paste0(temp_out$MIE, " ", temp_out$model)

temp_out <- temp_out[with(temp_out, order(x)),]

temp_out$x <- factor(temp_out$x, levels = unique(temp_out$x))

figure_catcher[["MCC_bargraph"]] <- ggplot(data = temp_out, aes(x= x, y=MCC, group = model)) + 
    geom_bar(stat="identity", aes(fill = MIE)) +
  xlab("MIE Name") +
  ylab("MCC") +
  ylim(c(0,1)) +
  guides(fill=guide_legend(title="MIEML Prediction")) +
  scale_fill_manual(values=fills) +
  theme_minimal() +
  #theme(axis.text.x = element_text(size = 10, angle = 60, vjust = 1, hjust=1),
theme(axis.text.x = element_text(size = 9),
        axis.text.y = element_blank(),
        strip.text.x = element_text(size = 9)) +
  coord_flip()
#  facet_grid(cols = vars(toxcast_prediction), scales = "free")


print(figure_catcher[["MCC_bargraph"]])
```
<br>

create plot of odds ratios
```{r}
figure_catcher[["OR_plot"]] <- ggplot(data = temp_out, aes(x= x, y=OR_magnitude, group = model)) + 
  geom_point(aes(color = MIE)) +
  geom_errorbar(aes(ymin = OR_lbound, ymax = OR_ubound, color = MIE)) +
  xlab("MIE Name") +
  ylab("Odds Ratio") +
  guides(color=guide_legend(title="MIEML Prediction")) +
  scale_color_manual(values=fills) +
  theme_minimal() +
theme(axis.text.x = element_text(size = 9),
        axis.text.y = element_blank(),
      axis.title.y = element_blank(),
      axis.ticks.y = element_blank(),
        strip.text.x = element_text(size = 9),
      legend.position = "none") +
  scale_y_continuous(trans='log10', limits = c(1,10000)) +
  coord_flip()

print(figure_catcher[["OR_plot"]])
```

How do AUCs compare for chemicals predicted to be ESR1 Agonists by the EDSP between MIEML active and MIEML inactive chems?
```{r fig.height=5, fig.width=8}
#subset to ESR1 data
ESR1_specific_data <- toxcast_mieml_summary_data[toxcast_mieml_summary_data$mie_flag == "ESR1 Agonism" & toxcast_mieml_summary_data$toxcast_prediction == "Toxcast Active",]

figure_catcher[["ESR1_EDSP_AUC_plot"]] <- ggplot(data = ESR1_specific_data, aes(x= MIEML_prediction, y=ESR1_Agonism_model_AUC)) + 
  geom_boxplot(aes(x= MIEML_prediction, y=ESR1_Agonism_model_AUC, color = MIEML_prediction), outlier.shape = NA) +
  geom_jitter(aes(color = MIEML_prediction), width = 0.2) +
  xlab("MIEML Prediction") +
  ylab("ToxCast_ER_AUC") +
  guides(fill=guide_legend(title="EDSP AUCs for MIEML Predictions")) +
  theme_minimal() +
theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust=1),
        axis.text.y = element_text(size = 9),
        strip.text.x = element_text(size = 9),
        legend.position = "none") +
  facet_grid(cols = vars(model_name))
#  coord_flip()

figure_catcher[["ESR1_EDSP_AUC_plot"]]
```

<br>

Save figure to disk
```{r}
tiff(filename = "../figures/ESR1_EDSP_AUC_plot.tiff", height = 5, width = 8, units = "in", res = 300)
figure_catcher[["ESR1_EDSP_AUC_plot"]]
dev.off()
```

<br>

Generate heatmap of all MIEML predictions (after filtering) with RefChemDB annotations and invitrodb derived predictions overlayed
```{r}
#make copy of data
data_for_plot <- MIEML_tcplfit2_hits

#round hitcall up to 1
data_for_plot[data_for_plot$hitcall >= 0.9,]$hitcall <- 1

#iterate through each MIE represented and generate an annotation column for each
for (target in unique(data_for_plot$pretty_MIE_name)){
  #target = unique(heatmap_object$pretty_MIE_name)[1]
  temp_data <- data.frame("dtxsid" = data_for_plot$dtxsid,
                          "holder" = NA)
  temp_data[temp_data$dtxsid %in% toxcast_coverage[toxcast_coverage$mie_flag == target,]$dtxsid,]$holder <- 0
  temp_data[temp_data$dtxsid %in% toxcast_hits[toxcast_hits$mie_flag == target,]$dtxsid,]$holder <- 1
  data_for_plot <- cbind(data_for_plot, temp_data$holder)
  names(data_for_plot)[ncol(data_for_plot)] <- paste0(target, " ToxCast")
}


data_for_plot <- data_for_plot[
  with(data_for_plot, order(pretty_MIE_name, model_name)),
]
```

<br>

Initialize heatmap object

```{r}
library(tidyr)
library(tibble)

heatmap_object <- data.frame(pivot_wider(data = data_for_plot[c("chem_id",
                                                                "name",
                                                                "hitcall", 
                                                                "dtxsid", 
                                                                "target_name",
                                                                "model_name",
                                                                "is_MIE_active_training_chem",
                                                                "exemplar_chemical_for_MIE",
                                                                "pretty_MIE_name")], 
                                         names_from = chem_id,
                                         values_from = hitcall,
                                         id_cols = c("pretty_MIE_name", 
                                                     "model_name"),
                                         values_fill = 0))

heatmap_object$pretty_MIE_name <- factor(heatmap_object$pretty_MIE_name, levels = c(unique(heatmap_object$pretty_MIE_name), "Other", "None"))

heatmap_object$model_name <- factor(heatmap_object$model_name, levels = unique(heatmap_object$model_name))
```

<br>

import RefChemDB annotations for incorporation with heatmap

```{r}
REFCHEMDB_PATH = "../data/refchemdb/NIHMS1537541-supplement-Supplement1.xlsx"

collapsed_refchemdb_targets <- collapse_refchemdb_targets(refchemdb_path = REFCHEMDB_PATH,
                                                        support_levels = c(3),
                                                        min_chemicals = 5,
                                                        cutree_h = 0.7,
                                                        cluster_method= "complete")

refchem_collapsed <- collapsed_refchemdb_targets$collapsed_targets

refchem_collapsed <- refchem_collapsed[refchem_collapsed$support >= 3,]

refchem_collapsed$pretty_MoA_name <- make_annotations_pretty(refchem_collapsed$target_mode)

#match chemicals in RefChemDB to only a single target, based on support level
stingy_target_annotations <- data.frame()
for (i in unique(refchem_collapsed$dsstox_substance_id)){
  relevant_targets <- refchem_collapsed[refchem_collapsed$dsstox_substance_id == i,]
  if(nrow(relevant_targets) > 0){
    relevant_targets <- relevant_targets[order(relevant_targets$support, decreasing = TRUE),]
    stingy_target_annotations <- rbind(head(relevant_targets, 1), stingy_target_annotations)
  }
}
refchem_collapsed <- stingy_target_annotations
rm(stingy_target_annotations)
```

<br>

Prepare annotations for mieml predictions and generate heatmap

```{r, fig.width=12, fig.height=6}
library(ComplexHeatmap)
library(circlize)

heatmap_matrix <- heatmap_object[3:ncol(heatmap_object)]

col_annotation_object <- data_for_plot

col_annotation_object <- unique(col_annotation_object[c("chem_id", 
                                                        "dtxsid",
                                                        "name",
                                                         names(col_annotation_object)[(ncol(col_annotation_object)-2) : ncol(col_annotation_object)])])

#add refchemdb annotations

#create a column and set it to none as a default for chemicals that are not represented in RefChemDB
col_annotation_object$refchemdb_linkage <- "None"

#add "Other" entry if chemicals are represented in RefChemDB - entry will be overwritten if target is among the three modeled
col_annotation_object[col_annotation_object$dtxsid %in% refchem_collapsed$dsstox_substance_id,]$refchemdb_linkage <- "Other"

#iterate through relevant targets - for chemicals in the dataset are linked to those targets, alter the annotation
for (target in unique(data_for_plot$pretty_MIE_name)){
  col_annotation_object[col_annotation_object$dtxsid %in% refchem_collapsed[refchem_collapsed$pretty_MoA_name == target,]$dsstox_substance_id,]$refchemdb_linkage <- target
}

col_annotation_object$refchemdb_linkage <- factor(col_annotation_object$refchemdb_linkage, levels = c(unique(data_for_plot$pretty_MIE_name), "Other", "None"))

col_annotation_object$`NR3C1 Agonism ToxCast` <- factor(col_annotation_object$`NR3C1 Agonism ToxCast`, 
                                                        levels = c(1,0))
col_annotation_object$`ESR1 Agonism ToxCast` <- factor(col_annotation_object$`ESR1 Agonism ToxCast`, 
                                                       levels = c(1,0))
col_annotation_object$`AHR Agonism ToxCast` <- factor(col_annotation_object$`AHR Agonism ToxCast`, 
                                                      levels = c(1,0))

 row_annotation_list <- list(`MIE Name` =  c(gg_color_hue(length(unique(heatmap_object$pretty_MIE_name)))),
                             Algorithm = c(gg_color_hue(length(unique(heatmap_object$model_name)))))
 
 names(row_annotation_list$`MIE Name`) <- levels(heatmap_object$pretty_MIE_name)[1:3]
 names(row_annotation_list$Algorithm) <- unique(heatmap_object$model_name)
 
  col_annotation_list <- list(`RefChemDB Annotation` =  c(gg_color_hue(length(unique(heatmap_object$pretty_MIE_name))), "black", "white"),
                             `NR3C1 Agonism ToxCast` =  c("blue", "grey"),
                             `ESR1 Agonism ToxCast` =  c("blue", "grey"),
                             `AHR Agonism ToxCast` =  c("blue", "grey"))
 
 names(col_annotation_list$`RefChemDB Annotation`) <- levels(col_annotation_object$refchemdb_linkage)
 names(col_annotation_list$`NR3C1 Agonism ToxCast`) <- levels(col_annotation_object$`NR3C1 Agonism ToxCast`)
 names(col_annotation_list$`ESR1 Agonism ToxCast`) <- levels(col_annotation_object$`ESR1 Agonism ToxCast`)
 names(col_annotation_list$`AHR Agonism ToxCast`) <- levels(col_annotation_object$`AHR Agonism ToxCast`)
 
ht_list <- Heatmap(name = "Prediction",
  as.matrix(heatmap_matrix),
                   column_title = "Chemical Sample",
                   row_title = "Model",
        col =  c("darkgrey", "blue"),
        cluster_columns = TRUE,
        cluster_rows = FALSE,
  show_column_dend = FALSE,
        show_heatmap_legend = TRUE,
        show_column_names = FALSE,
        show_row_names = FALSE,
        row_labels = heatmap_object$pretty_MIE_name,
        column_labels = col_annotation_object$name,
        left_annotation = rowAnnotation(`MIE Name` = heatmap_object$pretty_MIE_name,
                                           Algorithm = heatmap_object$model_name,
                                          col = row_annotation_list,
                                        simple_anno_size_adjust = TRUE),
        
         top_annotation = HeatmapAnnotation(`RefChemDB Annotation` = col_annotation_object$refchemdb_linkage,
                                           `NR3C1 Agonism ToxCast` = col_annotation_object$`NR3C1 Agonism ToxCast`,
                                           `ESR1 Agonism ToxCast` = col_annotation_object$`ESR1 Agonism ToxCast`,
                                           `AHR Agonism ToxCast` = col_annotation_object$`AHR Agonism ToxCast`,
                                          col = col_annotation_list,
                                          na_col = "white",
                                          simple_anno_size = unit(0.4, "cm"), 
                                          show_legend = c(TRUE, FALSE, FALSE, FALSE),
                                          annotation_name_side = "left"),
                                          heatmap_legend_param = list(legend_direction = "vertical"))

figure_catcher[["prediction_heatmap"]] <- grid.grabExpr(draw(ht_list,
     heatmap_legend_side = "bottom", 
     annotation_legend_side = "bottom",
     merge_legend = TRUE
     ))

draw(ht_list,
     heatmap_legend_side = "bottom", 
     annotation_legend_side = "bottom",
     merge_legend = TRUE
     )

```
<br>


Save figure to disk
```{r, fig.width=7, fig.height=9}
tiff(filename = "../figures/MIEML_prediction_heatmap.tiff", height = 5.2, width = 7, units = "in", res = 300)
draw(ht_list,
     heatmap_legend_side = "right", 
     annotation_legend_side = "right",
     merge_legend = FALSE
     )
dev.off()
```

<br>

Generate a multipanel figure combining figures that relate mieml and invitrodb predictions
```{r, fig.height=12, fig.width=10}
library(cowplot)

top_plot <- plot_grid(figure_catcher[["toxcast_histogram"]],
                      NULL,
                      figure_catcher[["OR_plot"]],
  labels = c("A", "B", ""),
          ncol = 3,
          nrow = 1,
#          rel_widths = c(1.0,1.0,1.0),
                       align = "h",
                       axis = "tb",
          rel_widths = c(1.5,0.08,1.2)
)

figure_catcher[["toxcast_combo"]]<- plot_grid(top_plot,
                                              NULL,
          figure_catcher[["prediction_heatmap"]],
  labels = c("","", "C"),
          ncol = 1,
          nrow = 3,
#          rel_widths = c(1.0,1.0,1.0),
          rel_heights = c(1.0,0.1,1.6)
)

figure_catcher[["toxcast_combo"]]
```
 <br>
 
Save to disk
```{r}
tiff(filename = "../figures/toxcast_prediction_combo.tiff", height = 12, width = 10, units = "in", res = 300)
figure_catcher[["toxcast_combo"]]
dev.off()
```

<br>

Save abbreviated version of this figure to disk
```{r}
tiff(filename = "../figures/toxcast_prediction_combo_top_only.tiff", height = 6, width = 10, units = "in", res = 300)
top_plot
dev.off()
```

<br>

Create a compact variant of this figure
```{r, fig.height=7, fig.width=15}
#reorder temp_out object to match heatmap row order
temp_out$x <- factor(temp_out$x, levels = rev(unique(temp_out$x)))

OR_plot <- ggplot(data = temp_out, aes(x= x, y=OR_magnitude, group = model)) + 
  geom_point(aes(color = MIE)) +
  geom_errorbar(aes(ymin = OR_lbound, ymax = OR_ubound, color = MIE)) +
  xlab("MIE Name") +
  ylab("Log10 Odds Ratio") +
  scale_color_manual(values=fills) +
theme(axis.text.x = element_text(size = 9),
      legend.position = "none",
        axis.text.y = element_blank(),
      axis.title.y = element_blank(),
      axis.ticks.y = element_blank(),
        strip.text.x = element_text(size = 9)) +
  scale_y_continuous(trans='log10', limits = c(1,10000)) +
  coord_flip()

plot_grid(OR_plot,
          figure_catcher[["prediction_heatmap"]],
  labels = c("", ""),
                         align = "v",
                       axis = "tb",
          ncol = 2,
          nrow = 1,
          rel_widths = c(0.5,1.5)
)
```

<br>

Generate a multipanel figure combining figures that relate to filtering of predictions by potency and consensus approach
```{r, fig.height=12, fig.width=12}


top_plot <- plot_grid(figure_catcher[["potency_ratio_scatter"]],
                                             figure_catcher[["consensus_histogram"]],
                                             labels = c("A", "B"),
                                             ncol = 2,
                                             nrow = 1,
                                             #align = "v",
                                             #axis = "lr",
                                             rel_widths = c(1.0,1.0)
)

figure_catcher[["sankey_combo"]]<- plot_grid(top_plot,
                                             figure_catcher[["lower_level_sankey"]],
                                             labels = c("", "C"),
                                             ncol = 1,
                                             nrow = 2,
                                             # align = "h",
                                             # axis = "tb",
                                             rel_heights  = c(1,1.8)
)




figure_catcher[["sankey_combo"]]
```

<br>

Save figure to disk

```{r}
tiff(filename = "../figures/sankey_combo.tiff", height = 12, width = 12, units = "in", res = 300)
figure_catcher[["sankey_combo"]]
dev.off()
```

<br>

How many chemicals achieved a positive hitcall for only a single MIE?

```{r}
temp <- data.table(MIEML_tcplfit2_hits)
temp <-  temp[,.(unique_targets=length(unique(pretty_MIE_name))),by=dtxsid]
nrow(temp[temp$unique_targets > 1,])
nrow(temp[temp$unique_targets == 1,])
```
<br>

Print session info
```{r}
sessionInfo()
```

